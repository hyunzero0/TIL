# 상속

- 다른 클래스가 가지고 있는 멤버(필드, 메소드)들을 새로 작성할 클래스에서 직접 만들지 않고 상속을 받음으로써 새 클래스가 자신의 멤버처럼 사용할 수 있는 기능
- 상속의 목적
    - 클래스의 재사용, 연관된 일련의 클래스들에 대한 공통적인 규약 정의
- 상속의 장점
    - 보다 적은 양의 코드로 새로운 클래스 작성가능
    - 코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경 용이
    - 코드의 중복을 제거하여 프로그램의 생산성/유지보수에 크게 기여

<br>

### 💸상속의 특징

- 모든 클래스는 Object 클래스의 후손
    - Object클래스가 제공하는 메소드를 오버라이딩하여 메소드 재구현 가능
    
    > java.lang.String 클래스의 equals()와 toString()
    
- 부모클래스의 생성자, 초기화 블록은 상속 안됨
    - 자식 클래스 생성 시, 부모 클래스 생성자가 먼저 실행
    - 자식 클래스 생성자 안에 부모 클래스 생성자를 호출하고 싶으면 super() 활용
- 부모의 private멤버는 상속은 되지만 직접 접근 불가
    - 자식 객체 생성 시 부모의 필드 값도 전달 받은 경우,
    자식 생성자 안에서 부모듸 private 필드에 직접 접근하여 대입 불가
    - super() 이용하여 전달받은 부모 필드 값을 부모 생성자 쪽으로 넘겨 생성하거나 setter/getter 메소드를 이용하여 접근

<br>

### 💸상속

- 방법
    - 클래스 간의 상속 시에는 extends 키워드 사용
- 표현식

    > [접근제한자] class 클래스명 extends 클래스명 {}

    ```java
    public class Academy extends Company {}
    //Academy = 자식클래스, Company = 부모클래스
    ```

<br>

### 💸단일 상속과 다중 상속

- 단일 상속
    - 클래스간의 관계가 다중 상속보다 명확하고 신뢰성 있는 코드 작성
- 다중 상속(java에서는 미지원)
    - C++에서 가능한 기능, 여러 클래스로부터 상속을 받으며 복합적인 기능을 가진 클래스를 쉽게 작성 가능
    - 서로 다른 클래스로부터 상속 받은 멤버 간의 이름이 같은 경우 문제 발생

<br>

### 💸super()와 super.

- super()
    - 부모 생성자를 호출하는 메소드, 기본적으로 후손 생성자에 부모 생성자 포함되어 있음
    - 후손 객체 생성 시에는 부모부터 생성이 되기 때문에 후손클래스 생성자 안에는 부모 생성자를 호출하는 super()가 첫 줄에 존재
    - 매개변수 있는 부모 생성자 호출은 super(매개변수)
- super.
    - 상속을 통한 자식 클래스 정의 시 해당 자식 클래스의 부모 객체를 가리키는 참조변수
    - 자식 클래스 내에서 부모 클래스 객체에 접근하여 필드나 메소드 호출 시 사용

<br>

### 💸오버라이딩(Overriding)

- 자식 클래스가 상속 받은 부모 메소드를 재작성하는 것
- 부모가 제공하는 기능을 후손이 일부 고쳐 사용하겠다는 의미
- 자식 객체를 통한 실행 시 후손 것이 우선권을 가짐
- 특징
    - 메소드 헤드라인 위에 반드시 Annotation, @Override 표시
    - 접근 제어자를 부모 것보다 같거나 넓은 범위로 변경 가능
    - 부모 메소드의 예외처리 클래스 처리범위보다 좁은 범위로 예외처리 클래스 수정 가능
- 성립조건
    - 부모 클래스의 메소드와 자식 클래스의 메소드 비교
        - 메소드 이름 동일
        - 매개변수 개수, 타입 동일
        - 리턴 타입 동일
        - private 메소드 오버라이딩 불가
        - final 메소드 오버라이딩 불가

<br>

### 💸오버로딩(Overloading)

- 한 클래스 내에서 같은 이름의 메소드를 여러 개 정의하는 것
- 성립 조건
    - 같은 메소드 이름
    - 다른 매개변수 선언부(매개변수 타입, 개수, 순서)
- 주의사항
    - 메소드의 리턴타입은 오버로딩 조건과 관계 없음

<br>

### 💸오버라이딩과 오버로딩

| 오버라이딩 | 오버로딩 |
| --- | --- |
| 하위 클래스에서 메소드 정의 | 같은 클래스에서 메소드 정의 |
| 메소드 이름 동일<br>매개변수 동일(개수, 타입)<br>리턴 타입 동일 | 메소드 이름 동일<br>매개변수 다름(개수, 타입)<br>리턴 타입 상관 없음 |
| 자식 메소드의 접근 범위가 부모 메소드의 접근 범위보다 넓거나 같아야 함 | 접근 제어자와 상관 없음 |
| 자식 메소드의 예외 수가 부모 메소드의 예외 수보다 적거나 범위가 좁아야 함 | 예외처리와 상관 없음 |

<br>

### 💸final 예약어

- final 클래스

    > 📢 상속이 불가능한 클래스
    > - public final class FinalClass {}

- final 메소드

    > 📢 상속 시 오버라이딩이 불가능한 메소드
    > - public final void method() {}

<br>

| 대상 | 사용 가능한 제어자/예약어 |
| --- | --- |
| 클래스 | public, (default), final, abstract |
| 메소드 | 모든 접근 제어자, final, abstract, static |
| 변수 | 모든 접근 제어자, final, static |
| 지역변수 | final |

- 유의사항
    - 클래스에 abstract와 final 동시 사용 불가능
    - 메소드에 static과 abstract 동시 사용 불가능
    - abstract 메소드의 접근제어자로 private 불가능