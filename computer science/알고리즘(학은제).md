# 알고리즘(학은제)

> ### [목차]
> 1. [1-1 알고리즘 정의와 다양한 알고리즘 문제](#1-1-알고리즘-정의와-다양한-알고리즘-문제)
> 2. [1-2 알고리즘의 특징 및 알고리즘 복잡도 표기법](#1-2-알고리즘의-특징-및-알고리즘-복잡도-표기법)

<br>

## 1-1 알고리즘 정의와 다양한 알고리즘 문제

### 🔍알고리즘 정의

문제를 해결하기 위한 단계적인 절차를 의미
- 효율적인 알고리즘 고안이 중요
- 여러 종류의 알고리즘이 있을 수 있으나, 항상 보다 효율적인 알고리즘을 고안하는 것이 매우 중요

<br>

### 🔍다양한 문제와 알고리즘

#### 1. 임의의 숫자 찾기
- 순차 탐색(Sequential Search) 
    - 원하는 숫자가 나올 때까지 하나하나 탐색<br>
-> 처음에 있으면 빠르지만, 마지막에 있으면 그만큼 느려짐

- 이진 탐색(Binary Search)
    - 순차 탐색보다 효율적으로 찾을 수 있음
    - 숫자를 오름차순으로 정렬 후 가운데 숫자를 내가 찾는 숫자와 비교
    - 내가 찾으려는 숫자 범위에 없는 절반의 숫자는 확인 필요없음

    > 1. 오름차순으로 데이터를 정렬
    > 2. 중간 숫자와 K 비교한 후 같으면 탐색 성공
    > 3. K가 작으면 앞부분 반에서 같은 방법으로 K를 찾음
    > 4. K가 크면 뒷부분 반에서 같은 방법으로 K를 찾음

<br>

#### 2. 동전 거스름돈
물건을 사고 거스름돈을 동전으로 받아야 한다면?
- 대부분 가장 적은 수의 동전을 원함

<br>

> 가장 큰 액면의 동전부터 차례로 찾기
> - 남은 거스름돈 액수를 넘지 않는 한도에서 가장 큰 액면의 동전을 계속하여 선택<br>
> -> 그리디(Greedy) 알고리즘 : 현재 최선의 방법을 먼저 사용

<br>

#### 3. 한붓 그리기
현재 점으로 돌아오는 사이클이 있으면 진행
- 단, 외길이면 즉, 인접한 점이 하나밖에 없으면 사이클 체크 없이 인접한 점으로 진행

<br>

#### 4. 미로 찾기
그리스 신화에서 아테네의 한 젊은 청년 테세우스는 칼과 실타래를 가지고 실을 풀면서 미로에 들어감
미노타우르를 칼로 죽이고, 실을 다시 감으면서 미로를 빠져나옴

> 실제 미로 찾기
> - 대부분의 경우 실타래가 없음
> - 이러한 상황에서 어떻게 미로를 빠져나올 수 있을까?

> 일반적인 방법
> 1. 현 위치에서 한 방향을 선택하여 이동
> 2. 길이 막혀 있으면 다시 되돌아 나옴
> 3. 다른 방향으로 다시 시도
> 4. 가능하다면 지나갔던 곳을 표시해 놓고 다시 안감

> 오른손 법칙
> 1. 현 위치에서 한 방향을 선택하고, 오른손을 벽에 댄다.
> 2. 출구가 나올 때까지 계속 오른손을 벽에서 떼지 않고 계속 걸어간다.

<br>

#### 5. 가짜 동전 찾기
아주 많은 동전 속에 1개의 가짜 동전이 있음
- 가짜 동전은 눈으로 식별 불가능
- 가짜 동전의 무게는 정상적인 동전보다 약간 가벼움

<br>

> 1. 동전 1개를 저울 왼편에 올리고, 나머지 동전을 하나씩 오른편에 올려서 가짜를 찾기<br>
> **1~(n-1)회**
> - 운이 좋으면 1번 만에 가짜 동전을 찾음
> - 최악은 가장 마지막에 가짜 동전을 올려놓게 되는 경우

> 2. 동전을 2개씩 짝을 지어, n/2 짝을 각각 저울에 달아서 가짜 동전을 찾아보자<br>
> **1~n/2회**
> - 최악의 경우 저울 사용 횟수가 거의 1/2로 감소

> 3. 동전 더미를 반으로 나누어 저울 양편에 놓아보자<br>
> **log2 n번** 
> - 남은 동전 수는 계속 1/2로 줄어들고, 나중에 2개가 남았을 때 가짜 동전을 가려냄

<br>

#### 6. 독이 든 술단지
많은 술단지 중 하나에 독이 들어있음. 눈으로 확인할 수 없고, 아주 조금만 맛보아도 정확이 일주일 후에 죽음

> 술단지가 2개일 때
> - 한 명의 신하가 1개의 술단지의 술을 맛 봄
> - 일주일 후 살아있다면 맛보지 않은 단지에 독이 있고, 아니라면 맛본 술단지에 독이 있음

> 술단지가 4개일 때
> - 세 사람이 각각 한 개씩 맛본다면..
> - 두 사람으로 줄일 수 없을까?<br>
>   - 문제점 : 맛보지 않은 2개의 단지 중 하나에 독이 들어있으면 어느 하나에 독이 들어 있는지를 알 수 없음

> 아이디어
> - 4개의 단지 중에서 두개의 술단지는 각각 마심
> - 나머지 두개의 단지 중에 하나를 두 신하에게 동시에 맛을 보게 함

> 알고리즘 : 각 단지에 2진수를 0부터 부여함
> - 첫 비트가 1이면 신하 1이 맛 봄
> - 둘째 비트가 1이면 신하 2가 맛봄
> - K번째 비트가 1이면 신하 K가 맛봄(ex: 11이면 신하1, 신하2 모두 맛봄)
> 
> 술단지 수가 n이면<br>
> **희생자 수 = 0~log2 n**

<br>

### 🔍요점정리

- **순차 탐색(Sequential Search)** : 주어진 순서에 따라 차례로 탐색
- **이진 탐색(Binary Search)** : 정렬된 데이터에 대해서 중간에 있는 데이터를 비교하여 그 결과에 따라 같으면 탐색을 마치고, 다르면 작은 쪽 또는 큰 쪽을 같은 방식으로 탐색
- **그리디(Greedy) 알고리즘** : 동전 거스름돈 문제에서 가장 액면이 높은 동전을 항상 욕심 내어 선택함
- 한붓그리기 문제는 오일러 서킷(Euler Circuit) 문제와 같음
    - 알고리즘의 핵심은 현재 점에서 **사이클이 존재하면 진행함**
- **분할 정복(Divide-and-Conquer) 알고리즘** : 가짜 동전 찾기에서 동전더미를 반으로 분할하여 저울에 달고, 가짜 동전이 있는 더미를 계속해서 반으로 나누어 저울에 담
- 독이든 술 단지 문제는 **2진수를 활용**하여 해를 찾음

<br>

## 1-2 알고리즘의 특징 및 알고리즘 복잡도 표기법